<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PHero Tube</title>
    <!-- Font awesome -->
    <script src="https://kit.fontawesome.com/13b995a34b.js" crossorigin="anonymous"></script>
    <!-- Google fonts  -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
        rel="stylesheet">
    <!-- Tailwind & Daisy Ui -->
    <link href="https://cdn.jsdelivr.net/npm/daisyui@3.6.4/dist/full.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="container mx-auto p-2" style="font-family: 'Inter', sans-serif;">
    <!-- Header Section Start -->
    <header>
        <!-- Navbar Section Start -->
        <nav class="flex flex-nowrap gap-1 md:gap-28 lg:gap-[30%] my-9 justify-between items-center">
            <a href="./index.html"><img class="md:flex-1 lg:flex-1" src="./images/Logo.png" alt="Logo"></a>
            <a href="./blog.html">
                <button
                    class="md:flex-1 lg:flex-1 py-2 rounded-lg px-5 text-black bg-[#25252526] focus:bg-[#FF1F3D] focus:font-semibold focus:text-white">Blog</button>
            </a>
        </nav>
        <hr class="my-7">
        <!-- Navbar Section End -->
    </header>
    <!-- Header Section End -->
    <main class="flex flex-col justify-center gap-20">
        <!-- blog 1 -->
        <div class="space-y-8">
            <h1 class="text-3xl md:text-6xl text-black font-bold">
                Discuss the scope of var, let, and const:
            </h1>
            <img class="h-[80vh] w-[100vw] md:w-[70vw] md:mx-auto"
                src="https://www.freecodecamp.org/news/content/images/size/w2000/2023/01/15.-var-let-const.png"
                alt="image">
            <p class="text-xl md:text-2xl font-semibold text-black">In JavaScript, the scope of variables
                declared with var, let, and const differs in terms of how they are accessible within your code.
                Understanding these scopes is crucial for writing predictable and maintainable code: <br><br>

                var:
            <ol class="text-xl md:text-2xl font-semibold text-black">
                <li><b>Function Scope:</b> Variables declared with var have function scope. This means they are only
                    accessible within the function in which they are defined.</li>
                <li> <br>
                    <b>Hoisting:</b> Variables declared with var are hoisted to the top of their containing function or
                    global scope. This means that even if you reference a var variable before it's declared, JavaScript
                    will move the declaration to the top of the function during execution (though not the
                    initialization).
                </li> <br>

                <li>
                    <b>Global Scope:</b> If var is declared outside of any function, it becomes a global variable and is
                    accessible throughout the entire script.
                </li>
            </ol>
            <br><br>
            <b class="text-xl md:text-2xl font-semibold text-black">Example:</b> <br> <br>

            <code>
                function exampleScope() { <br>
                    var x = 10; <br>
                    if (true) { <br>
                        var y = 5; <br>
                    } <br>
                    console.log(x); // 10, accessible <br>
                    console.log(y); // 5, accessible, no block scope <br>
                    } <br>
                    
                    console.log(x); // ReferenceError: x is not defined, not in global scope <br>
                    
            </code> <br>

            <b class="text-xl md:text-2xl font-semibold text-black">let:</b>

            <ol class="text-xl md:text-2xl font-semibold text-black">
                <li>
                    <b>Block Scope:</b> Variables declared with let have block scope, which means they are only
                    accessible
                    within
                    the block (enclosed by curly braces {}) or function in which they are defined
                </li> <br>
                <li>
                    <b>Hoisting:</b> let variables are hoisted to the top of their containing block or function, but
                    they are
                    not initialized. Accessing them before their declaration results in a
                </li> <br>

                <li>
                    <b>No Global Object Property: </b>Unlike var, let does not become a property of the global object
                    (e.g., window in browsers).
                </li>
            </ol>

            <b class="text-xl md:text-2xl font-semibold text-black">Example:</b> <br> <br>

            <code>
                function exampleScope() { <br>
                    let x = 10;<br>
                    if (true) {<br>
                        let y = 5;<br>
                    }<br>
                    console.log(x); // 10, accessible<br>
                    console.log(y); // ReferenceError: y is not defined, block-scoped<br>
                    }<br>
                  console.log(x); // ReferenceError: x is not defined, not in global scope<br>
                    
            </code> <br>

            <b class="text-xl md:text-2xl font-semibold text-black">const:</b>

            <ol class="text-xl md:text-2xl font-semibold text-black">
                <li>
                    <b>Block Scope:</b> Variables declared with const also have block scope, just like let.
                </li> <br>
                <li>
                    <b>Hoisting:</b> const variables are hoisted to the top of their containing block or function, but
                    they are not initialized. Accessing them before their declaration results in a ReferenceError.
                </li> <br>

                <li>
                    <b>Immutable Reference:</b> const variables are typically used for values that should not be
                    reassigned.
                    The variable itself is immutable, meaning its binding cannot be changed, but the value it points to
                    may not be immutable (e.g., objects and arrays can still be modified).
                </li>
            </ol>

            <b class="text-xl md:text-2xl font-semibold text-black">Example:</b> <br> <br>

            <code> <br>
                function exampleScope() { <br>
                    const x = 10; <br>
                    if (true) { <br>
                        const y = 5; <br>
                    } <br>
                    console.log(x); // 10, accessible <br>
                    console.log(y); // ReferenceError: y is not defined, block-scoped <br>
                    }
                    
                  console.log(x); // ReferenceError: x is not defined, not in global scope <br>
                    
                    
            </code> <br>

            <b class="text-xl md:text-2xl font-semibold text-black">In summary, var has function scope and can cause
                issues with variable hoisting and global scope pollution, while let and const have block scope, are not
                hoisted in the same way, and are generally preferred for modern JavaScript code because they provide
                better control and predictability over variable scoping and reassignment.</b>







            </p>
        </div>
        <!-- blog 2 -->
        <div class="space-y-9">
            <h1 class="text-3xl md:text-6xl text-black font-bold">The use cases of null and undefined
            </h1>
            <img class="h-[80vh] w-[100vw] md:w-[70vw] md:mx-auto"
                src="https://www.freecodecamp.org/news/content/images/size/w2000/2023/01/15.-var-let-const.png"
                alt="image">
            <p class="text-xl md:text-2xl font-semibold text-black">
                In programming, null and undefined are two distinct values that are often used to represent the absence
                of a meaningful value or to indicate missing or uninitialized data. While they are similar in some ways,
                they have different use cases and meanings in various programming languages. Let's explore the use cases
                of null and undefined: <br> <br>
                Null:
            <ul class="text-xl md:text-2xl font-semibold text-black">
                <li><b>Explicit Absence of Value:</b> null is often used when you want to explicitly indicate that a
                    variable
                    or object has no value or that a value is intentionally missing.</li> <br>
                <li><b>User-Defined Empty State:</b> It can be assigned by developers to variables or properties to
                    indicate an
                    empty state, especially when working with data structures like arrays or objects.</li> <br>

                <li><b>As a Sentinel Value:</b> In some cases, <b>null</b> is used as a sentinel or placeholder value to
                    mark a variable or object for later initialization or as a placeholder for missing data.</li> <br>

                <li><b>Comparisons:</b> You can compare a variable against null to check if it has been deliberately set
                    to
                    indicate the absence of a value.</li>
            </ul>
            <br>


            <code class="bg-slate-200">let myVariable = null; // Explicitly set to indicate absence of value <br>
                let myObject = { name: null, age: 25 }; // Using null to represent missing data
                </code>


            <br>
            <br>

            <b class="text-4xl ">undefined</b>
            <ul class="text-xl md:text-2xl font-semibold text-black">
                <li><b>Implicit Absence of Value:</b>
                    undefined typically represents the absence of a value when a variable or object hasn't been
                    initialized or when a property doesn't exist in an object.
                </li> <br>
                <li>
                    <b>Function Parameters:</b>
                    When a function is called with fewer arguments than expected, the missing parameters are
                    automatically assigned the value undefined.
                </li> <br>
                <li>
                    <b>Variable Declarations:</b>
                    Variables declared without an assigned value are initialized with undefined.
                </li> <br>
                <li>
                    <b>Object Properties:</b>
                    Accessing an object property that doesn't exist returns undefined.
                </li>
            </ul>

            <br>
            <br>

            <code class="bg-slate-200">
                let someVar; // Declared but not initialized, so it's undefined <br>
                function printMessage(message) { <br>
                    console.log(message);<br>
                } <br>
                printMessage(); // 'message' is not passed, so it's undefined in the function <br> <br>
                let myObject = { name: "John" }; <br>
                console.log(myObject.age); // 'age' property doesn't exist, so it's undefined

            </code> <br> <br>

            <b class="text-2xl">
                In summary, null is typically used to represent an intentional absence of a value or to indicate a
                specific
                empty state that a developer assigns, while undefined usually represents the absence of a value due to
                uninitialized variables, missing function arguments, or non-existent object properties. The choice
                between
                null and undefined depends on the specific use case and the meaning you want to convey in your code.
            </b>
            </p>


        </div>
        <!-- blog 3 -->
        <div class="space-y-8">
            <h1 class="text-3xl md:text-6xl text-black font-bold">What do you mean by REST API?
            </h1>
            <img class="h-[80vh] w-[100vw] md:w-[70vw] md:mx-auto"
                src="https://images.ctfassets.net/vwq10xzbe6iz/5sBH4Agl614xM7exeLsTo7/9e84dce01735f155911e611c42c9793f/rest-api.png"
                alt="image">
            <p class="text-xl md:text-2xl font-semibold text-black">REST API, which stands for
                Representational State Transfer Application Programming Interface, is a set of architectural principles
                and constraints for designing networked applications. It is an approach to building web services that
                allows different software applications to communicate with each other over the internet or a network.
                <br> <br>

                <b>Here are the key principles and concepts of REST API:</b> <br><br>

                <b>Resources:</b> In a REST API, everything is considered a resource, such as data objects, services, or
                entities. Each resource is identified by a unique URL (Uniform Resource Locator). <br> <br>

                <b>HTTP Methods:</b> REST APIs use standard HTTP methods for performing operations on resources.
                <br><br> <b> The four primary HTTP methods used in REST are:</b> <br><br>

                1. GET: Retrieve data from the server (read-only). <br>
                2 . POST: Create a new resource on the server. <br>
                3 . PUT: Update an existing resource or create it if it doesn't exist. <br>
                4 . DELETE: Remove a resource from the server. <br> <br>

                <b>Stateless:</b> REST APIs are stateless, meaning that each request from a client to the server must
                contain
                all the information needed to understand and process the request. The server doesn't store any client
                state between requests. <br> <br>

                <b>Representation:</b> Resources in a REST API can have multiple representations, such as JSON, XML,
                HTML, or
                others. Clients can request the representation they prefer by specifying the appropriate content type in
                the request headers. <br> <br>

                <b>Uniform Interface:</b> REST APIs have a uniform and consistent interface, which simplifies
                interaction
                between clients and servers. This uniformity is achieved through the use of standard HTTP methods and
                status codes. <br> <br>

                <b>Statelessness:</b> Each request from a client to a server must contain all the information needed to
                understand and fulfill the request. The server should not store any client state between requests. <br>
                <br>

                <b>Client-Server Architecture:</b> REST follows a client-server architecture, where the client and
                server are
                separate entities that communicate over a network. This separation of concerns allows for scalability
                and flexibility. <br> <br>

                <b>Layered System:</b> REST allows for the use of intermediary components, such as load balancers,
                caches, and
                gateways, to improve system performance, scalability, and security. <br> <br>

                <b>Cacheability:</b> Responses from the server can be explicitly marked as cacheable or non-cacheable,
                allowing
                for efficient use of caching mechanisms.

                Stateless Communication: Each request from the client to the server should be complete and
                self-contained, and the server should not rely on any previous requests. <br> <br>

                REST APIs are commonly used in web development to create web services that can be accessed by various
                clients, including web browsers, mobile apps, and other server-side applications. They provide a
                flexible and scalable way to interact with and manipulate data over the internet while adhering to a set
                of well-defined principles.
            </p>
        </div>

    </main>
</body>

</html>